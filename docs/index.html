<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Spring Data Mock</title>
    <link href="https://fonts.googleapis.com/css?family=IBM+Plex+Mono:400,800|IBM+Plex+Sans:400,800" rel="stylesheet">

    <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre.min.css">
    <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre-exp.min.css">
    <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre-icons.min.css">

    <style>
        html, body {
            font-family: "IBM Plex Sans",-apple-system,system-ui,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",sans-serif
        }
        .code {
            color: dodgerblue;
        }
    </style>
</head>
<body>

<div class="container max-width-xs">
    <header class="navbar">
        <section class="navbar-section">
            <a href="#" class="btn btn-link">Download</a>
            <a href="#" class="btn btn-link">Docs</a>
            <a href="#" class="btn btn-link">Support</a>
            <a href="#" class="btn btn-link">About</a>
        </section>
        <section class="navbar-center">
            <a href="#" class="navbar-brand mr-2">Spring Data Mock</a>
        </section>
        <section class="navbar-section">
            <div class="input-group input-inline">
                <input class="form-input" type="text" placeholder="search">
                <button class="btn btn-primary input-group-btn">Search</button>
            </div>
        </section>
    </header>
</div>

<div class="container content max-width-xs" style="margin-top:120px;">
    <div class="columns">
        <div class="column col-3">

            <ul class="nav">
                <li class="nav-item">
                    <a href="#">Elements</a>
                </li>
                <li class="nav-item active">
                    <a href="#">Layout</a>
                    <ul class="nav">
                        <li class="nav-item">
                            <a href="#">Flexbox grid</a>
                        </li>
                        <li class="nav-item">
                            <a href="#">Responsive</a>
                        </li>
                        <li class="nav-item">
                            <a href="#">Navbar</a>
                        </li>
                        <li class="nav-item">
                            <a href="#">Empty states</a>
                        </li>
                    </ul>
                </li>
                <li class="nav-item">
                    <a href="#">Components</a>
                </li>
                <li class="nav-item">
                    <a href="#">Utilities</a>
                </li>
            </ul>

        </div>
        <div class="column col-9">

            <h1 class="ui header">Spring Data Mock</h1>

            <section class="ui vertical segment" id="introduction">
                <h2 class="ui header">Introduction</h2>
                <p>
                    This is a fairly flexible, versatile framework for mocking Spring Data repositories. Spring Data provides a
                    very good foundation for separating the concerns of managing a database and its subsequently resulting
                    queries from those of the business layer.
                </p>
                <p>
                    This is great for writing services. They only need to depend upon Spring Data repositories and manage their
                    data through this level of indirection. This, however, means that for testing purposes, you will either have
                    to write lots of boilerplate code for your Spring powered application, or you will have to start up a full
                    blown application context with a backing database.
                </p>
                <p>
                    For most test cases, this is entirely unnecessary and, moreover, creates time burdens and takes away
                    valuable time from productive tasks. This is why I decided to write this framework: to avoid the unnecessary
                    effort, and to have a reliable infrastructure replicating what Spring would do with an actual database, only
                    in-memory. This will allow for mocking the repository with actual data. Thus, you can test your services
                    without having to start up the application context, and with the highest level of isolation -- with actual
                    data.
                </p>
            </section>

            <section class="ui vertical segment" id="quick-start">
                <h2 class="ui header">Quick Start</h2>
                <p>
                    Regardless of how you add the necessary dependency to your project, mocking a repository can be as
                    simple as:
                </p>
                <pre class="code"><code>builder().mock(UserRepository.class);</code></pre>
                <p>
                    where <code class="inline">builder()</code>
                    is a static method of the <code class="inline">RepositoryFactoryBuilder</code>
                    class under package <code class="inline">com.mmnaseri.utils.spring.data.dsl.factory</code>.
                </p>
                <p>
                    The full code for that would be:
                </p>
<pre class="code"><code class="lang-java">import static com.mmnaseri.utils.spring.data.dsl.factory.RepositoryFactoryBuilder.builder;
public class UserServiceTest {
    private UserRepository repository;
    private UserService service;

    @BeforeMethod
    public void setUp() {
        repository = builder().mock(UserRepository.class);
        repository.save(new User(&amp;quot;test&amp;quot;, &amp;quot;securePassword&amp;quot;));
        service = new UserService(repository);
    }

    @Test
    public void testUserLookUp() {
        User user = service.load(&amp;quot;test&amp;quot;);
    }
}</code></pre>
                <p>
                    An alternate way of mocking a repository would be by using the
                    <code class="inline">RepositoryMockBuilder</code>
                    class under the <code class="inline">com.mmnaseri.utils.spring.data.dsl.mock</code>
                    package:
                </p>
<pre class="code"><code class="lang-java">
final RepositoryFactoryConfiguration configuration = ... ;
final UserRepository repository = new RepositoryMockBuilder().useConfiguration(configuration).mock(UserRepository.class);
</code></pre>
            </section>
            <section class="ui vertical segment" id="mocking-a-repository">
                <h2 class="ui header">Mocking a Repository</h2>
                <p>
                    To mock a repository you must somehow use the underlying <code class="inline">RepositoryFactory</code>.
                    There is currently a single implementation of this interface available,
                    <code class="inline">com.mmnaseri.utils.spring.data.proxy.impl.DefaultRepositoryFactory</code>.
                    The factory has a <code class="inline">getInstance(...)</code> method that let's you customize the
                    mocking for each instance of the repository you create. This means that you can mock a single
                    repository multiple times, each time with a different set of behaviors:
                </p>
<pre class="code"><code class="lang-java">
final UserRepository repository = factory.getInstance(keyGenerator, UserRepository.class, Implementation1.class, Implementation2.class);
</code></pre>
                <p>
                    There are three components to this method call:
                </p>
                <ol>
                    <li>The <strong>key generator</strong> (which can be <code class="inline">null</code>)
                        will determine the strategy for generating keys for the ID field for an entity when it is inserted into
                        the underlying data store.
                    </li>
                    <li>
                        The <strong>repository interface</strong> which is the interface you want to instantiate and have
                        proxied for you.
                    </li>
                    <li>
                        The <strong>custom implementations</strong> (which are optional) that can provide custom ways of
                        handling repository method calls.
                    </li>
                </ol>
                <p>
                    A minimal way of instantiating a repository would be:
                </p>
<pre class="code"><code class="lang-java">
final UserRepository repository = factory.getInstance(null,UserRepository.class);
</code></pre>
                <p>
                    which falls back on the default way of generating keys, and relies solely on default implementations
                    for handling method calls.
                </p>
            </section>
            <section class="ui vertical segment" id="repository-factory-configuration">
                <h2 class="ui header">Repository Factory Configuration</h2>
                <p>
                    The default repository factory implementation takes in a configuration object which will let you
                    customize multiple aspects of the mocking mechanism.
                </p>
                <p>
                    The configuration object allows you the following customizations:
                </p>
                <ul>
                    <li>
                        Change the way <em>repository metadata</em> is resolved from a given repository class object.
                        The following metadata is required to work with a repository and to be able to efficiently mock
                        its intended behavior: 1) the entity type, 2) the type of the identifier 3) the property
                        corresponding to the identifier.
                    </li>
                    <li>
                        Change the way a <em>query method name</em> is parsed and converted into a data filter object.
                        By default, query methods which follow the standard declared by Spring Data are parsed and
                        honored. Additionally, the first word is taken as a function and can thus be used to implement
                        custom behavior. This is to enable extension in case of further support by the Spring Data team.
                        Also, the operators (such as "Is Greater Than", "Is Equal To", "Is Between", etc.) are
                        customizable.
                    </li>
                    <li>
                        Customize the set of available aggregate and operational <em>functions</em>.
                    </li>
                    <li>
                        Customize the underlying <em>data store</em> mapping for each entity type. By default, storage
                        is done in-memory. But there is nothing preventing you from attaching the data store for a
                        particular type of entity to another source. All you have to do is to implement the
                        <code class="inline">com.mmnaseri.utils.spring.data.store.DataStore</code> interface and add it
                        to this context. It is actually much easier than it sounds.
                    </li>
                    <li>
                        Decide <em>how results should be adapted</em> from an actual value returned from implementation
                        methods to the way a repository method is supposed to return values. This is to allow, for
                        instance, to implement a <code class="inline">findAll</code> method that returns a collection of
                        items, and then reuse its implementation for a repository method named
                        <code class="inline">findAll</code> that is supposed to return a set.
                    </li>
                    <li>
                        Set <em>default implementations</em> for particular repository types and subtypes.
                    </li>
                    <li>
                        Add and customize <em>event listeners</em> to data store actions. These can listen to events before and
                        after inserting, updating, and deleting a particular entity.
                    </li>
                    <li>
                        Decide how repository methods that are strictly non-data (e.g.
                        <code class="inline">.equals(...)</code>) are to be handled
                    </li>
                    <li>
                        And what the default key generation scheme should be in case no key generator is specified for the given
                        repository
                    </li>
                </ul>
                <p>
                    Since the configuration object is complex and can be a hassle to create, you can use the much easier
                    to use DSL via the
                    <code class="inline">com.mmnaseri.utils.spring.data.dsl.factory.RepositoryFactoryBuilder</code>
                    class. We will go over that shortly.
                </p>
            </section>
            <section class="ui vertical segment" id="using-the-dsl-to-mock-a-repository">
                <h2 class="ui header">Using the DSL to Mock a Repository</h2>
                <p>
                    Once you have a configuration object at hand, you can use the DSL bundled with this framework to easily
                    mock your repositories and avoid going through the RepositoryFactory class.
                </p>
                <p>
                    You can mock a repository this way:
                </p>
<pre class="code"><code class="lang-java">final RepositoryMockBuilder builder = new RepositoryMockBuilder();
final UserRepository repository = builder
    .useConfiguration(configuration)
    .generateKeysUsing(UUIDKeyGenerator.class)
    .usingImplementation(SampleImpl1.class)
    .and(SampleImpl2.class)
    .and(SampleImpl3.class)
    .mock(UserRepository.class);</code></pre>
                <p>
                    You have to note that this builder is <em>stateless</em>, meaning that each of the methods in this
                    builder will not modify an internal state, but rather return an object which reflects all the
                    configurations up to this point.
                </p>
                <p>
                    To better understand this concept, let's look at the following example:
                </p>
<pre class="code"><code class="lang-java">final RepositoryMockBuilder base = new RepositoryMockBuilder();
final RepositoryMockBuilder builder1 = base.useConfiguration(configuration)
    .generateKeysUsing(UUIDKeyGenerator.class)
    .usingImplementation(SampleImpl1.class);
final RepositoryMockBuilder builder2 = base.useConfiguration(configuration)
    .generateKeysUsing(NoOpKeyGenerator.class)
    .usingImplementation(SampleImpl2.class);</code></pre>
                <p>
                    This is by design, and is to allow developers and testers the freedom of reusing their
                    configurations.
                </p>
            </section>
            <section class="ui vertical segment" id="using-the-dsl-to-create-a-configuration">
                <h2 class="ui header">Using the DSL to Create a Configuration</h2>
                <p>
                    Whereas mocking a repository is a relatively painless process and might not require the use of a
                    dedicated DSL, creating a configuration is another story altogether. In recognition of this fact, I
                    have created a DSL for this very purpose, so that you can craft configurations using a
                    <em>stateful</em> builder via this DSL:
                </p>
<pre class="code"><code class="lang-java">final RepositoryFactoryBuilder builder = RepositoryFactoryBuilder.builder()
    .resolveMetadataUsing(...)
    .registerOperator(...) //register some operator
        .and(...).and(...) //register other operators
    .registerFunction(...) //register data function
        .and(...).and(...) //register additional data functions
    .registerDataStore(...) //register a data store to be used in the configured repositories
        .and(...).and(...)//register additional data stores
    .adaptResultsUsing(...) //register a result adapter
        .and(...).and(...)//register additional result adapters
    .honoringImplementation(...) //add some custom implementation on a global scope
        .and(...).and(...)//register additional implementations
    .withOperationHandler(...) //register other operation handlers
        .and(...).and(...) //add more operation handlers
    .withDefaultKeyGenerator(...) //set the default key generator
    .enableAuditing(...) //enable support for Spring Data&amp;#39;s auditing and pass in a custom auditor aware instance
    .withListener(...) //register some event listener
        .and(...).and(...)//register additional event listeners
</code></pre>
                <p>
                    At this stage, you can either call to the
                    <code class="inline">configure()</code>
                    method on the builder object to get a configuration object, or you can skip this step and
                    continue from the key generation step of the mock builder (marked with three stars in the previous
                    listing). Alternatively, you can call
                    <code class="inline">build()</code>
                    to get an instance of the repository factory, which you can use to instantiate mock repositories.
                </p>
                <p>
                    All of the steps above are optional. All values have defaults and you can skip setting them and still
                    expect everything to just work out of the box.
                </p>
                <p>
                    Here is a complete list of the terms you can use in the DSL to configure the repository factory:
                </p>
                <table class="table">
                    <thead>
                    <tr>
                        <th>Term</th>
                        <th>Explanation</th>
                        <th>Default Behavior</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <td><code class="inline">resolveMetadataUsing</code></td>
                        <td>tells the configurer to use the provided metadata resolver</td>
                        <td><code class="inline">~.domain.impl.DefaultRepositoryMetadataResolver</code> will be used
                        </td>
                    </tr>
                    <tr>
                        <td><code class="inline">withOperators</code></td>
                        <td>tells the configurer to use the provided operator context</td>
                        <td><code class="inline">~.domain.impl.DefaultOperatorContext</code> will be used
                        </td>
                    </tr>
                    <tr>
                        <td><code class="inline">registerOperator</code></td>
                        <td>registers an operator with the operator context</td>
                        <td>only the operators in the <code class="inline">DefaultOperatorContext</code> will be used</td>
                    </tr>
                    <tr>
                        <td><code class="inline">withDataFunctions</code></td>
                        <td>tells the configurer to use the provided data function registry</td>
                        <td><code class="inline">~.query.impl.DefaultDataFunctionRegistry</code> will be used
                        </td>
                    </tr>
                    <tr>
                        <td><code class="inline">registerFunction</code></td>
                        <td>registers a function with the default context</td>
                        <td>only default functions will be registered</td>
                    </tr>
                    <tr>
                        <td><code class="inline">withDataStores</code></td>
                        <td>tells the configurer to use the provided data store registry</td>
                        <td><code class="inline">~.store.impl.DefaultDataStoreRegistry</code> will be used
                        </td>
                    </tr>
                    <tr>
                        <td><code class="inline">registerDataStore</code></td>
                        <td>registers a data store</td>
                        <td>no data store will be registered by default</td>
                    </tr>
                    <tr>
                        <td><code class="inline">withAdapters</code></td>
                        <td>tells the configurer to use the provided result adapter context</td>
                        <td><code class="inline">~.proxy.impl.DefaultResultAdapterContext</code> will be used
                        </td>
                    </tr>
                    <tr>
                        <td><code class="inline">adaptResultsUsing</code></td>
                        <td>registers an adapter</td>
                        <td>no additional adapters will be used</td>
                    </tr>
                    <tr>
                        <td><code class="inline">withMappings</code></td>
                        <td>tells the configurer to use the provided type mapping context</td>
                        <td><code class="inline">~.proxy.impl.DefaultTypeMappingContext</code> will be used
                        </td>
                    </tr>
                    <tr>
                        <td><code class="inline">honoringImplementation</code></td>
                        <td>registers a type with the type mapping context</td>
                        <td>only the defaults provided will be used</td>
                    </tr>
                    <tr>
                        <td><code class="inline">withOperationHandlers</code></td>
                        <td>tells the configurer to use the provided non-data operation handler context</td>
                        <td>the default context will be used</td>
                    </tr>
                    <tr>
                        <td><code class="inline">withOperationHandler</code></td>
                        <td>registers an operation handler with the context</td>
                        <td>the default handlers will be used</td>
                    </tr>
                    <tr>
                        <td><code class="inline">withDefaultKeyGenerator</code></td>
                        <td>registers a default, fallback key generator for the repository factory</td>
                        <td>no fallback will be used</td>
                    </tr>
                    <tr>
                        <td><code class="inline">withListeners</code></td>
                        <td>tells the configurer to use the provided event listener context</td>
                        <td><code class="inline">~.store.impl.DefaultDataStoreEventListenerContext</code>
                            will be used
                        </td>
                    </tr>
                    <tr>
                        <td><code class="inline">withListener</code></td>
                        <td>adds the provided event listener</td>
                        <td>no listener will be added</td>
                    </tr>
                    <tr>
                        <td><code class="inline">enableAuditing</code></td>
                        <td>
                            enables Spring Data auditing. You can also provide an
                            <code class="inline">AuditorAware</code>. If you don't provide anything, a default will be
                            used which assumes user to be a string and it will have a  value of
                            <code class="inline">User</code>
                        </td>
                        <td>auditing will not be enabled</td>
                    </tr>
                    <tr>
                        <td><code class="inline">build</code></td>
                        <td>builds and returns a repository factory</td>
                        <td>N/A</td>
                    </tr>
                    <tr>
                        <td><code class="inline">configure</code></td>
                        <td>builds and returns a repository factory configuration</td>
                        <td>N/A</td>
                    </tr>
                    </tbody>
                </table>
                <p>
                    To answer the question of what all of these configurable steps mean, we need to go to the next
                    section.
                </p>
            </section>

            <section class="ui vertical segment" id="the-mechanics">
                <h2 class="ui header">The Mechanics</h2>
                <p>
                    In this section, we will detail the framework and go over how each part of it can be configured.
                </p>
            </section>
            <section class="ui vertical segment" id="metadata-resolver">
                <h2 class="ui header">Metadata Resolver</h2>
                <p>
                    The metadata resolver is an entity that is capable of looking at a repository interface and figuring
                    out detail about the repository as well as the persistent entity it is supporting. This is what the
                    metadata resolver will find out:
                </p>
                <ul>
                    <li>the type of the entity for which the repository has been created</li>
                    <li>the (actual or encapsulated) property of the persistent entity which holds the identifier.</li>
                    <li>the type of the identifier associated with the entity</li>
                </ul>
                <p>
                    The default metadata resolver is the
                    <code class="inline">com.mmnaseri.utils.spring.data.domain.impl.DefaultRepositoryMetadataResolver</code>
                    class, which will first see if the repository is annotated with
                    <code class="inline">@org.springframework.data.repository.RepositoryDefinition</code>
                    and if not tries to extract its metadata from the interface should it extend
                    <code class="inline">org.springframework.data.repository.Repository</code>.
                </p>
                <p>
                    If none of these conditions are met, it will throw an exception.
                </p>
                <div class="alert alert-warning">
                    <h2 class="ui header" id="primitive-ids">Primitve IDs</h2>
                    <p>
                        At this point, we do not support primitive identifier types. This means that if your ID type is
                        <code class="inline">long</code>, you will have to change it to
                        <code class="inline">java.lang.Long</code> to be able to use this framework.</p>
                </div>
            </section>

            <section class="ui vertical segment" id="the-operators">
                <h2 class="ui header">The Operators</h2>
                <p>
                    The operators are what drive how the query methods are parsed. This is the general recipe:
                </p>
                <p>
                    At each juncture, we look for the operator whose tokens matches the longest suffix, and assume the
                    rest to be a property path, so that for instance, if we are parsing
                    "ParentParentAgeGreaterThanEqual", we will match it with the operator "GreaterThanEqual", and
                    consider the "ParentParentAge" to be a property path (which might be
                    <code class="inline">parent.parent.age</code>.
                </p>
                <p>
                    Each operator has a <code class="inline">Matcher</code>, which will help identify whether or not
                    based on a given criteria an entity instance matches the query.
                </p>
                <p>
                    By extending the operators, you can practically extend the query method DSL. This might not be
                    practical, as we might not want to support things that Spring Data doesn't support yet, but it
                    allows for a better maintainability and easier extensibility should Spring Data actually expand
                    beyond what it is today.
                </p>
                <p>
                    Below is a list of the default operators that ship with this framework:
                </p>
                <table class="table">
                    <thead>
                    <tr>
                        <th>Operator</th>
                        <th>Suffixes</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <td>AFTER</td>
                        <td>
                            <code class="inline">After</code>,
                            <code class="inline">IsAfter</code>
                        </td>
                    </tr>
                    <tr>
                        <td>BEFORE</td>
                        <td>
                            <code class="inline">Before</code>,
                            <code class="inline">IsBefore</code>
                        </td>
                    </tr>
                    <tr>
                        <td>CONTAINING</td>
                        <td>
                            <code class="inline">Containing</code>,
                            <code class="inline">IsContaining</code>,
                            <code class="inline">Contains</code>
                        </td>
                    </tr>
                    <tr>
                        <td>BETWEEN</td>
                        <td>
                            <code class="inline">Between</code>,
                            <code class="inline">IsBetween</code>
                        </td>
                    </tr>
                    <tr>
                        <td>NOT_BETWEEN</td>
                        <td>
                            <code class="inline">NotBetween</code>,
                            <code class="inline">IsNotBetween</code>
                        </td>
                    </tr>
                    <tr>
                        <td>ENDING_WITH</td>
                        <td>
                            <code class="inline">EndingWith</code>,
                            <code class="inline">IsEndingWith</code>,
                            <code class="inline">EndsWith</code>
                        </td>
                    </tr>
                    <tr>
                        <td>FALSE</td>
                        <td>
                            <code class="inline">False</code>,
                            <code class="inline">IsFalse</code>
                        </td>
                    </tr>
                    <tr>
                        <td>GREATER_THAN</td>
                        <td>
                            <code class="inline">GreaterThan</code>,
                            <code class="inline">IsGreaterThan</code>
                        </td>
                    </tr>
                    <tr>
                        <td>GREATER_THAN_EQUALS</td>
                        <td>
                            <code class="inline">GreaterThanEqual</code>,
                            <code class="inline">IsGreaterThanEqual</code>
                        </td>
                    </tr>
                    <tr>
                        <td>IN</td>
                        <td>
                            <code class="inline">In</code>,
                            <code class="inline">IsIn</code>
                        </td>
                    </tr>
                    <tr>
                        <td>IS</td>
                        <td>
                            <code class="inline">Is</code>,
                            <code class="inline">EqualTo</code>,
                            <code class="inline">IsEqualTo</code>,
                            <code class="inline">Equals</code>
                        </td>
                    </tr>
                    <tr>
                        <td>NOT_NULL</td>
                        <td>
                            <code class="inline">NotNull</code>,
                            <code class="inline">IsNotNull</code>
                        </td>
                    </tr>
                    <tr>
                        <td>NULL</td>
                        <td>
                            <code class="inline">Null</code>,
                            <code class="inline">IsNull</code>
                        </td>
                    </tr>
                    <tr>
                        <td>LESS_THAN</td>
                        <td>
                            <code class="inline">LessThan</code>,
                            <code class="inline">IsLessThan</code>
                        </td>
                    </tr>
                    <tr>
                        <td>LESS_THAN_EQUAL</td>
                        <td>
                            <code class="inline">LessThanEqual</code>,
                            <code class="inline">IsLessThanEqual</code>
                        </td>
                    </tr>
                    <tr>
                        <td>LIKE</td>
                        <td>
                            <code class="inline">Like</code>,
                            <code class="inline">IsLike</code>
                        </td>
                    </tr>
                    <tr>
                        <td>NEAR</td>
                        <td>
                            <code class="inline">Near</code>,
                            <code class="inline">IsNear</code>
                        </td>
                    </tr>
                    <tr>
                        <td>NOT</td>
                        <td>
                            <code class="inline">IsNot</code>,
                            <code class="inline">Not</code>,
                            <code class="inline">IsNotEqualTo</code>,
                            <code class="inline">DoesNotEqual</code>
                        </td>
                    </tr>
                    <tr>
                        <td>NOT_IN</td>
                        <td>
                            <code class="inline">NotIn</code>,
                            <code class="inline">IsNotIn</code>
                        </td>
                    </tr>
                    <tr>
                        <td>NOT_LIKE</td>
                        <td>
                            <code class="inline">NotLike</code>,
                            <code class="inline">IsNotLike</code>
                        </td>
                    </tr>
                    <tr>
                        <td>REGEX</td>
                        <td>
                            <code class="inline">Regex</code>,
                            <code class="inline">MatchesRegex</code>,
                            <code class="inline">Matches</code>
                        </td>
                    </tr>
                    <tr>
                        <td>STARTING_WITH</td>
                        <td>
                            <code class="inline">StartingWith</code>,
                            <code class="inline">IsStartingWith</code>,
                            <code class="inline">StartsWith</code>
                        </td>
                    </tr>
                    <tr>
                        <td>TRUE</td>
                        <td>
                            <code class="inline">True</code>,
                            <code class="inline">IsTrue</code>
                        </td>
                    </tr>
                    </tbody>
                </table>
                <p>
                    If no suffix is present to determine the operator by, it is assumed that the
                    <code class="inline">IS</code> operator was intended.
                </p>
            </section>

            <section class="ui vertical segment" id="data-functions">
                <h2 class="ui header">Data Functions</h2>
                <p>
                    Data functions determine what should be done with a particular selection of entities before a result
                    is  returned. For instance, the <code class="inline">count</code> data function just returns the
                    collection size for a subset of data, thus allowing you to start your query method with
                    <code class="inline">count</code> and expect it to return the size of the
                    selection.
                </p>
                <p>
                    By extending the data functions, you are also extending the DSL for query methods by allowing
                    various new data function names to be used in the beginning of a query method's name.
                </p>
                <p>
                    Available data functions:
                </p>
                <table class=" table">
                    <thead>
                    <tr>
                        <th>Function</th>
                        <th>Description</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <td><code class="inline">count</code></td>
                        <td>Returns the number of items that were selected</td>
                    </tr>
                    <tr>
                        <td><code class="inline">delete</code></td>
                        <td>Deletes all the selected items</td>
                    </tr>
                    </tbody>
                </table>
            </section>

            <section class="ui vertical segment" id="data-stores">
                <h2 class="ui header">Data Stores</h2>
                <p>
                    This framework has an abstraction hiding away the details of where and how entities are stored and
                    are looked up. The default behavior is, of course, to keep everything in memory. It might, however,
                    be necessary to delegate this to some external service or entity, such as an im-memory data store, a
                    distributed cache, or an actual database.
                </p>
                <p>
                    All you have to do is implement the
                    <code class="inline">com.mmnaseri.utils.spring.data.store.DataStore</code> interface and point it to
                    the right direction.
                </p>
                <p>
                    Currently available implementations of the data store abstraction are:
                </p>
                <ul>
                    <li>
                        <code class="inline">com.mmnaseri.utils.spring.data.store.impl.MemoryDataStore</code> which, as
                        the name implies, holds everything in memory
                    </li>
                    <li>
                        <code class="inline">com.mmnaseri.utils.spring.data.store.impl.EventPublishingDataStore</code>
                        which acts as a wrapper around another, delegate data store to add event publishing
                        capabilities.
                    </li>
                </ul>
                <p>
                    A data store has to support these operations:
                </p>
                <ul>
                    <li><code class="inline">hasKey</code>: to be able to tell whether or not it contains a given entity</li>
                    <li><code class="inline">save</code>: to store an object at a given key</li>
                    <li><code class="inline">delete</code>: to delete an item by its key</li>
                    <li><code class="inline">retrieve</code>: to return an object from a key</li>
                    <li><code class="inline">keys</code>: to return all the keys that it has stored</li>
                    <li><code class="inline">retrieveAll</code>: to return all the entities that it has stored</li>
                    <li><code class="inline">truncate</code>: to delete all items at once</li>
                    <li><code class="inline">getEntityType</code>: to tell us what type of object it is storing</li>
                </ul>
                <p>
                    As you can see, this is a good abstraction of a key-value store that is centered around a particular
                    object type.
                </p>
                <p>
                    This abstraction let's us create a separate data store for each object type, and bind them to their
                    individual repositories.
                </p>
                <p>
                    Additionally, if you want to support more sophisticated operations and enable batching and operation
                    queueing, your repository can implement
                    <code class="inline">com.mmnaseri.utils.spring.data.store.QueueingDataStore</code>
                    which introduces the following three operations:
                </p>
                <ul>
                    <li><code class="inline">flush</code>: to flush the queue and commit all
                        issued operations
                    </li>
                    <li><code class="inline">startBatch</code>: to start a batch of operations</li>
                    <li><code class="inline">end</code>: to end the batch that was indicated
                    </li>
                </ul>
                <p>
                    Certain repository methods can take advantage of these additional functionality if provided.
                </p>
            </section>

            <section class="ui vertical segment" id="result-adapters">
                <h2 class="ui header">Result Adapters</h2>
                <p>
                    Many times the actual implementation methods for an operation return very generic results, such as a list or
                    a set, whereas the required return type for the repository interface method might be something else. Suppose
                    for instance, that the implementation method returns a List, while the interface method returns just one
                    instance.
                </p>
                <p>
                    In such cases, it is necessary to adapt the results to the output format, and that is exactly what the
                    result adapters are for.
                </p>
                <p>
                    They have a priority order which dictates in what order they will be executed:
                </p>
                <table class=" table">
                    <thead>
                    <tr>
                        <th>Adapter</th>
                        <th>Converts from</th>
                        <th>Converts to</th>
                        <th>Priority</th>
                        <th>Description</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <td><code class="inline">VoidResultAdapter</code></td>
                        <td><code class="inline">void</code></td>
                        <td><code class="inline">*</code></td>
                        <td><code class="inline">-inf</code></td>
                        <td></td>
                    </tr>
                    <tr>
                        <td><code class="inline">SameTypeResultAdapter</code></td>
                        <td><code class="inline">*</code></td>
                        <td><code class="inline">*</code></td>
                        <td><code class="inline">-500</code></td>
                        <td>Used when the source and target are of the same type</td>
                    </tr>
                    <tr>
                        <td><code class="inline">NumberIterableResultAdapter</code></td>
                        <td><code class="inline">Number</code></td>
                        <td><code class="inline">Iterable</code></td>
                        <td><code class="inline">-425</code></td>
                        <td></td>
                    </tr>
                    <tr>
                        <td><code class="inline">SimpleIterableResultAdapter</code></td>
                        <td><code class="inline">*</code></td>
                        <td><code class="inline">Iterable</code></td>
                        <td><code class="inline">-400</code></td>
                        <td>When we want to convert an object to its iterable</td>
                    </tr>
                    <tr>
                        <td><code class="inline">NullSimpleResultAdapter</code></td>
                        <td><code class="inline">null</code></td>
                        <td><code class="inline">Object</code></td>
                        <td><code class="inline">-400</code></td>
                        <td>Used when target type is a single object</td>
                    </tr>
                    <tr>
                        <td><code class="inline">NullToIteratorResultAdapter</code></td>
                        <td><code class="inline">null</code></td>
                        <td><code class="inline">Iterator</code></td>
                        <td><code class="inline">-350</code></td>
                        <td></td>
                    </tr>
                    <tr>
                        <td><code class="inline">IteratorIterableResultAdapter</code></td>
                        <td><code class="inline">Iterator</code></td>
                        <td><code class="inline">Iterable</code></td>
                        <td><code class="inline">-350</code></td>
                        <td></td>
                    </tr>
                    <tr>
                        <td><code class="inline">NullToCollectionResultAdapter</code></td>
                        <td><code class="inline">null</code></td>
                        <td><code class="inline">Collection</code></td>
                        <td><code class="inline">-300</code></td>
                        <td></td>
                    </tr>
                    <tr>
                        <td><code class="inline">CollectionIterableResultAdapter</code></td>
                        <td><code class="inline">Collection</code></td>
                        <td><code class="inline">Iterable</code></td>
                        <td><code class="inline">-300</code></td>
                        <td></td>
                    </tr>
                    <tr>
                        <td><code class="inline">SliceIterableResultAdapter</code></td>
                        <td><code class="inline">Slice</code></td>
                        <td><code class="inline">Iterable</code></td>
                        <td><code class="inline">-250</code></td>
                        <td></td>
                    </tr>
                    <tr>
                        <td><code class="inline">NullToIterableResultAdapter</code></td>
                        <td><code class="inline">null</code></td>
                        <td><code class="inline">Iterable</code></td>
                        <td><code class="inline">-250</code></td>
                        <td></td>
                    </tr>
                    <tr>
                        <td><code class="inline">NullToSliceResultAdapter</code></td>
                        <td><code class="inline">null</code></td>
                        <td><code class="inline">Slice</code></td>
                        <td><code class="inline">-200</code></td>
                        <td></td>
                    </tr>
                    <tr>
                        <td><code class="inline">PageIterableResultAdapter</code></td>
                        <td><code class="inline">Page</code></td>
                        <td><code class="inline">Iterable</code></td>
                        <td><code class="inline">-200</code></td>
                        <td></td>
                    </tr>
                    <tr>
                        <td><code class="inline">NullToFutureResultAdapter</code></td>
                        <td><code class="inline">null</code></td>
                        <td><code class="inline">Future</code></td>
                        <td><code class="inline">-150</code></td>
                        <td></td>
                    </tr>
                    <tr>
                        <td><code class="inline">GeoPageIterableResultAdapter</code></td>
                        <td><code class="inline">GeoPage</code></td>
                        <td><code class="inline">Iterable</code></td>
                        <td><code class="inline">-150</code></td>
                        <td></td>
                    </tr>
                    <tr>
                        <td><code class="inline">NullToListenableFutureResultAdapter</code></td>
                        <td><code class="inline">null</code></td>
                        <td><code class="inline">ListenableFuture</code></td>
                        <td><code class="inline">-100</code></td>
                        <td></td>
                    </tr>
                    <tr>
                        <td><code class="inline">FutureIterableResultAdapter</code></td>
                        <td><code class="inline">Future</code></td>
                        <td><code class="inline">Iterable</code></td>
                        <td><code class="inline">-100</code></td>
                        <td></td>
                    </tr>
                    <tr>
                        <td><code class="inline">ListenableFutureIterableResultAdapter</code></td>
                        <td><code class="inline">ListenableFuture</code></td>
                        <td><code class="inline">Iterable</code></td>
                        <td><code class="inline">-50</code></td>
                        <td></td>
                    </tr>
                    </tbody>
                </table>
            </section>

            <section class="ui vertical segment" id="custom-implementations-and-type-mapping-context">
                <h2 class="ui header">Custom Implementations and Type Mapping Context</h2>
                <p>
                    You can map custom implementations to repository interfaces. To this end, a type mapping context
                    exists which will let you bind particular repository interface super types to custom implementation
                    classes. The methods are then looked up according to their signature.
                </p>
                <p>
                    Implementations registered with a type mapping context are made available to all repository factory
                    instances and are thus shared.
                </p>
                <p>
                    When proxying a repository method this is the order with which a method is bound to an
                    implementation:
                </p>
                <ol>
                    <li>
                        We first look for custom implementations supplied directly to the factory while requesting a
                        mock instance
                    </li>
                    <li>We look at globally available implementations supplied through the configuration object</li>
                    <li>We try to interpret the method name as a query.</li>
                </ol>
            </section>

            <section class="ui vertical segment" id="spring-data-extensions">
                <h2 class="ui header">Spring Data Extensions</h2>
                <p>
                    Spring Data extensions are modules provided by the Spring Data team or third parties that provide
                    additional support for more data sources.
                </p>
                <p>
                    These extensions can receive support from this mocking framework if you register a corresponding
                    implementation in the type mapping context.
                </p>
                <p>
                    We have implemented the following data extensions.
                </p>
            </section>

            <section class="ui vertical segment" id="support-for-crudrepository">
                <h2 class="ui header">Support for CrudRepository</h2>
                <p>
                    All methods introduced in
                    <code class="inline">org.springframework.data.repository.CrudRepository</code> are implemented in a
                    class called
                    <code class="inline">com.mmnaseri.utils.spring.data.repository.DefaultCrudRepository</code>. This
                    class is registered with the type mapping for all repositories by default.
                </p>
            </section>

            <section class="ui vertical segment" id="support-for-pagingandsortingrepository">
                <h2 class="ui header">Support for PagingAndSortingRepository</h2>
                <p>
                    All methods introduced in
                    <code class="inline">org.springframework.data.repository.PagingAndSortingRepository</code>
                    are implemented in a class called
                    <code class="inline">com.mmnaseri.utils.spring.data.repository.DefaultPagingAndSortingRepository</code>.
                    This class is registered with the type mapping for all repositories by default.
                </p>
            </section>

            <section class="ui vertical segment" id="support-for-query-by-example-">
                <h2 class="ui header">Support for "Query by Example"</h2>
                <p>
                    Query by example is a concept introduced in Spring Data 1.12 and as such might not be shipped with
                    your version of Spring Data by default.
                </p>
                <p>
                    That is why we first check to see if interface
                    <code class="inline">org.springframework.data.repository.query.QueryByExampleExecutor</code>
                    is found in the classpath. If so, then we register supporting type
                    <code class="inline">com.mmnaseri.utils.spring.data.repository.DefaultQueryByExampleExecutor</code>
                    which includes methods that are capable of taking care of all methods introduced in this interface.
                </p>
            </section>

            <section class="ui vertical segment" id="support-for-querydsl">
                <h2 class="ui header">Support for QueryDSL</h2>
                <p>
                    There is an extension for <a href="http://www.querydsl.com">QueryDSL</a> for Spring Data that will
                    let you use a fluent API to interact with the data store, while hiding away the complexities of
                    talking to the database itself.
                </p>
                <p>
                    If the <code class="inline">org.springframework.data.querydsl.QueryDslPredicateExecutor</code>
                    interface is found in the classpath and, additionally, we can also find the CGLib library in the
                    classpath (which is required for QueryDSL to function), we assume QueryDSL support to be enabled. We
                    then add the
                    <code class="inline">com.mmnaseri.utils.spring.data.repository.DefaultQueryDslPredicateExecutor</code>
                    implementation to the type mapping context.
                </p>
            </section>

            <section class="ui vertical segment" id="note-on-additional-dependencies">
                <h2 class="ui header">Note on additional dependencies</h2>
                <p><code class="inline">DefaultQueryDslPredicateExecutor</code> uses the <code class="inline"><span
                        class="hljs-selector-tag">com.querydsl<span
                        class="hljs-selector-pseudo">:querydsl-collections</code> to query the underlying data store mock
                    the same way as the QueryDSL framework itself. As such, if you want to be able to mock repositories that use
                    QueryDSL
                    operations, you will have to add a dependency to <code class="inline">querydsl-collections</code>:
                </p>
<pre class="code"><code class="xml">&lt;dependency&gt;
    &lt;groupid&gt;com.querydsl&lt;/groupid&gt;
    &lt;artifactid&gt;querydsl-collections&lt;/artifactid&gt;
    &lt;version&gt;${latest-version}&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
            </section>

            <section class="ui vertical segment" id="support-for-jpa">
                <h2 class="ui header">Support for JPA</h2>
                <p>
                    If we can find <code class="inline">org.springframework.data.jpa.repository.JpaRepository</code>
                    in the classpath, we assume JPA support to be added. As such, we will register
                    <code class="inline">com.mmnaseri.utils.spring.data.repository.DefaultJpaRepository</code>
                    which will take care of all the methods in the <code class="inline">JpaRepository</code> interface
                    that are not already handled by other extensions.
                </p>
            </section>

            <section class="ui vertical segment" id="gemfire-support">
                <h2 class="ui header">Gemfire Support</h2>
                <p>If
                    <code class="inline">org.springframework.data.gemfire.repository.GemfireRepository</code>
                    is found in the classpath, we will assume that you want to be able to mock Gemfire repositories as
                    well. That is why we register
                    <code class="inline">com.mmnaseri.utils.spring.data.repository.DefaultGemfireRepository</code>
                    to be able to take care of Gemfire-specific methods that aren't found on regular repositories.
                </p>
            </section>

            <section class="ui vertical segment" id="non-data-operation-handlers">
                <h2 class="ui header">Non-Data-Operation Handlers</h2>
                <p>
                    Non-data-operation handlers, as the name suggests, are operation handlers that support invocation of
                    methods that are not data-specific. Examples include <code class="inline">Object.equals(...)</code>
                    and <code class="inline">Object.hashCode(...)</code>.
                </p>
                <p>
                    These are registered with <code class="inline">com.mmnaseri.utils.spring.data.proxy.impl.NonDataOperationInvocationHandler</code>
                    which has a <code class="inline">register(...)</code> method for the purpose.
                </p>
                <p>
                    You can implement your own handlers, which will be investigated and invoked in the order in which they were
                    registered, but these come with the framework:
                </p>
                <ul>
                    <li><code class="inline">com.mmnaseri<span
    >.utils<span
    >.spring.data<span
    >.proxy.impl<span
    >.regular<span
    >.EqualsNonDataOperationHandler</code>: for handling <code
                            class="inline"><span
                            class="hljs-built_in">Object.equals(<span
                            class="hljs-built_in">Object)</code>
                    </li>
                    <li><code class="inline">com.mmnaseri<span
    >.utils<span
    >.spring.data<span
    >.proxy.impl<span
    >.regular.HashCodeNonDataOperationHandler</code>
                        for handling <code class="inline">Object<span
        >.hashCode()</code></li>
                    <li><code class="inline">com.mmnaseri<span
    >.utils<span
    >.spring.data<span
    >.proxy.impl<span
    >.regular.ToStringNonDataOperationHandler</code>
                        for handling <code class="inline">Object<span
        >.toString()</code></li>
                </ul>
            </section>

            <section class="ui vertical segment" id="disclaimer">
                <h2 class="ui header">Disclaimer</h2>
                <p>
                    The credit for fixing this goes to @Kaidjin who went all ninja on this and helped resolve #12 in all speed.
                </p>
            </section>

            <section class="ui vertical segment" id="event-listeners">
                <h2 class="ui header">Event Listeners</h2>
                <p>
                    You can register event listeners for each of the following events:
                </p>
                <ul>
                    <li><code class="inline">BeforeInsertDataStoreEvent</code></li>
                    <li><code class="inline">AfterInsertDataStoreEvent</code></li>
                    <li><code class="inline">BeforeUpdateDataStoreEvent</code></li>
                    <li><code class="inline">AfterUpdateDataStoreEvent</code></li>
                    <li><code class="inline">BeforeDeleteDataStoreEvent</code></li>
                    <li><code class="inline">AfterDeleteDataStoreEvent</code></li>
                </ul>
                <p>
                    The event handlers can then modify, take note of, or otherwise interact with the entities for which the event
                    was raised.
                </p>
                <p>
                    If you use the <code class="inline"><span
                        class="hljs-title">enableAuditing<span
                        class="hljs-params">()</code> feature above, an event listener (<code
                        class="inline">com<span
>.mmnaseri.utils<span
>.spring.data<span
>.store.impl<span
>.AuditDataEventListener</code>)
                    will be registered with the configuration which will enable auditing features and will set relevant
                    properties in the appropriate juncture by listening closely to the events listed above.
                </p>
            </section>

            <section class="ui vertical segment" id="auditing">
                <h2 class="ui header">Auditing</h2>
                <p>
                    Out-of-the-box auditing is supported through this event mechanism for the usual
                    <code class="inline">CreatedBy</code>, <code class="inline">CreatedDate</code>,
                    <code class="inline">LastModifiedBy</code>, and <code class="inline">LastModifiedDate</code> audit
                    annotations provided by Spring Data Commons. To support user-related auditing (created by and last
                    modified by) you will need to supply an <code class="inline">AuditorAware</code> or accept the default one,
                    which will always return a String object with value,
                    <code class="inline"><span class="hljs-variable">&amp;quot;User
                        <span class="hljs-variable">&amp;quot;</code>.
                </p>
                <p>
                    By default, auditing is disabled. This is to follow in the footprints of Spring. Since Spring Data asks you
                    to explicitly enable auditing, this framework, too, pushes for the same requirement.
                </p>
            </section>

            <section class="ui vertical segment" id="note-on-additional-dependencies">
                <h2 class="ui header">Note on additional dependencies</h2>
                <p>
                    When you enable auditing, Spring Data will use the <code class="inline">joda-
                    time</code> library to achieve precision timestamping. As such, when you
                    enable auditing, you will have to add a dependency on <code class="inline">joda-<span
                        class="hljs-built_in">time:joda-time</code>.
                </p>
            </section>

            <section class="ui vertical segment" id="a-note-on-distinct-selections">
                <h2 class="ui header">A Note on Distinct Selections</h2>
                <p>
                    When using the <code class="inline">distinct</code> modifier for
                    selection, this framework will use the internal <code class="inline">
            hashCode()</code> of the object
                    being read from the data store abstraction to figure out distinct values.
                </p>
                <p>
                    This is because as opposed to most data stores, we do not have any notion of row-by-row or object-to-object
                    equality relations and at the moment we cannot figure out if two objects should be considered as equal,
                    unless they have a <code class="inline">hashCode</code>.
                </p>
                <p>
                    Having a <code class="inline">hashCode</code> is good programming
                    practice anyway, so I don't feel too bad about not having implemented this for the moment.
                </p>
            </section>

            <section class="ui vertical segment" id="referenced-objects">
                <h2 class="ui header">Referenced Objects</h2>
                <p>
                    In this framework referenced objects are not going to be separated out. We have not implemented a
                    full-fledged ORM and that is not the plan -- at least for the moment.
                </p>
                <p>
                    When you save an object such as this:
                </p>
                <pre class="code"><code class="lang-java">public <span
                        class="hljs-class">class <span
                        class="hljs-title">EntityA {
    <span class="hljs-meta">@Reference
    private EntityB referencedObject;
}
</code></pre>
                <p>
                    we are not going to automatically create a data store for the <code class="inline">EntityB</code> class and
                    store the values there. Though it doesn't seem to be to complicated to implement, at the moment it is not
                    how we do things.
                </p>
            </section>

            <section class="ui vertical segment" id="key-generation">
                <h2 class="ui header">Key Generation</h2>
                <p>
                    When storing data in the data store, we require a key. That is because the underlying data store abstraction
                    is essentially a key-value store.
                </p>
                <p>
                    This means that you will either have to provide keys for every entity you save, or that there must be some
                    sort of key generation mechanism in place to handle that for you. Well, luckily, there is one. Here is a
                    list of the various key generators that come with this framework, and you can easily add your own by
                    implementing <code class="inline">com<span
>.mmnaseri.utils<span
>.spring.data<span
>.domain<span
>.KeyGenerator</code>.
                </p>
                <ul>
                    <li><code class="inline">com.mmnaseri<span
    >.utils<span
    >.spring.data<span
    >.domain<span
    >.KeyGenerator</code>:
                        when you genuinely do not wish to generate keys automatically. This key generator
                        will basically generate <code class="inline">null</code> keys.
                    </li>
                    <li><code class="inline">com.mmnaseri<span
    >.utils<span
    >.spring.data<span
    >.domain.impl<span
    >.key<span
    >.UUIDKeyGenerator</code>:
                        generates UUID values and returns them as Strings.
                    </li>
                    <li><code class="inline">com.mmnaseri<span
    >.utils<span
    >.spring.data<span
    >.domain.impl<span
    >.key<span
    >.SequentialIntegerKeyGenerator</code>: generates <code
                            class="inline">int</code> values starting from <code
                            class="inline">1</code></li>
                    <li><code class="inline">com.mmnaseri<span
    >.utils<span
    >.spring.data<span
    >.domain.impl<span
    >.key<span
    >.SequentialLongKeyGenerator</code>:
                        generates <code class="inline">long</code> values starting from <code
                                class="inline">1</code></li>
                    <li><code class="inline">com.mmnaseri<span
    >.utils<span
    >.spring.data<span
    >.domain.impl<span
    >.key.ConfigurableSequentialIntegerKeyGenerator</code>:
                        generates <code class="inline">int</code> values that start
                        from a custom <code class="inline">initialValue</code> and increase/decrease by a custom <code
                                class="inline">step</code></li>
                    <li><code class="inline">com.mmnaseri<span
    >.utils<span
    >.spring.data<span
    >.domain.impl<span
    >.key.ConfigurableSequentialLongKeyGenerator</code>:
                        generates <code class="inline">long</code> values that start
                        from a custom <code class="inline">initialValue</code> and increase/decrease by a custom <code
                                class="inline">step</code></li>
                    <li><code class="inline">com.mmnaseri<span
    >.utils<span
    >.spring.data<span
    >.domain.impl<span
    >.key<span
    >.RandomIntegerKeyGenerator</code>: generates random, unique <code
                            class="inline">int</code> values
                    </li>
                    <li><code class="inline">com.mmnaseri<span
    >.utils<span
    >.spring.data<span
    >.domain.impl<span
    >.key<span
    >.RandomLongKeyGenerator</code>: generates random, unique <code
                            class="inline">long</code> values
                    </li>
                </ul>
                <p>
                    If you are using the DSL to configure the repository factory and do not mention which of the above to use,
                    and you don't explicitly say that you do not want key generation to be turned off, one of the above will be
                    chosen for you automatically based on the type of the key.
                </p>
            </section>

        </div>
    </div>
</div>

</body>
</html>